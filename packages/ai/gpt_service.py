"""
Enhanced GPT service for Awade AI system.
Handles OpenAI API interactions with improved ethical safeguards, cultural considerations, and prompt tuning.
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any
from openai import OpenAI
from .prompts import (
    LESSON_PLAN_PROMPT,
    CULTURAL_ADAPTATION_PROMPT,
    EXPLANATION_PROMPT,
    CURRICULUM_ALIGNMENT_PROMPT,
    ASSESSMENT_OPTIMIZATION_PROMPT,
    ACTIVITY_ENHANCEMENT_PROMPT
)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AwadeGPTService:
    """
    Enhanced ethical AI service for educational content generation.
    Implements improved safeguards, cultural considerations, and prompt tuning.
    """
    
    def __init__(self, api_key: Optional[str] = None, model: str = "gpt-4"):
        """Initialize the GPT service with API key and model configuration."""
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise ValueError("OpenAI API key is required")
        
        self.client = OpenAI(api_key=self.api_key)
        self.model = model
        
        # Enhanced ethical safeguards
        self.content_filters = [
            "inappropriate_content",
            "harmful_content",
            "biased_content",
            "culturally_insensitive_content",
            "age_inappropriate_content"
        ]
        
        # Performance optimization settings
        self.default_temperature = 0.7
        self.default_max_tokens = 1500
        self.retry_attempts = 3
        
    def generate_lesson_plan(
        self,
        subject: str,
        grade: str,
        topic: str,
        objectives: Optional[List[str]] = None,
        duration: int = 45,
        language: str = "en",
        cultural_context: str = "African",
        local_context: Optional[str] = None,
        curriculum_standards: Optional[List[str]] = None
    ) -> Dict:
        """
        Generate a culturally relevant lesson plan with enhanced prompt tuning.
        
        Args:
            subject: Subject area (e.g., "Mathematics", "Science")
            grade: Grade level (e.g., "Grade 4", "Grade 7")
            topic: Specific topic to teach
            objectives: List of learning objectives
            duration: Lesson duration in minutes
            language: Primary language for the lesson
            cultural_context: Cultural context for adaptations
            local_context: Local context information
            curriculum_standards: List of curriculum standards to align with
            
        Returns:
            Dict containing the generated lesson plan
        """
        try:
            # Handle optional objectives
            objectives_text = ", ".join(objectives) if objectives else "To be generated by AI"
            local_context_text = local_context or "General African context"
            curriculum_text = ", ".join(curriculum_standards) if curriculum_standards else "Standard curriculum"
            
            prompt = LESSON_PLAN_PROMPT.format(
                subject=subject,
                grade=grade,
                topic=topic,
                objectives=objectives_text,
                duration=duration,
                language=language,
                local_context=local_context_text
            )
            
            # Enhanced system message with better context
            system_message = f"""You are an expert African educator with deep knowledge of {subject} curriculum for {grade} level. 
            You specialize in creating culturally relevant, practical lesson plans that work in African classrooms.
            Focus on using locally available resources, respecting cultural values, and creating engaging learning experiences.
            Always consider the practical constraints of African schools and the diverse needs of students."""
            
            response = self._make_api_call(
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1500
            )
            
            # Parse and structure the response
            content = response.choices[0].message.content
            return self._structure_lesson_plan(content, subject, grade, topic, objectives, curriculum_standards)
            
        except Exception as e:
            logger.error(f"Error generating lesson plan: {str(e)}")
            return {
                "error": f"Failed to generate lesson plan: {str(e)}",
                "fallback": self._generate_fallback_lesson_plan(subject, grade, topic, objectives)
            }
    
    def optimize_assessment(
        self,
        assessment_content: str,
        subject: str,
        grade: str,
        assessment_type: str = "mixed"
    ) -> Dict:
        """
        Optimize assessment content for cultural relevance and effectiveness.
        
        Args:
            assessment_content: Current assessment content
            subject: Subject area
            grade: Grade level
            assessment_type: Type of assessment (quiz, project, etc.)
            
        Returns:
            Dict containing optimized assessment
        """
        try:
            prompt = ASSESSMENT_OPTIMIZATION_PROMPT.format(
                assessment_content=assessment_content,
                subject=subject,
                grade=grade,
                assessment_type=assessment_type
            )
            
            system_message = f"You are an assessment specialist with expertise in {subject} for {grade} level. Focus on creating culturally appropriate, effective assessments."
            
            response = self._make_api_call(
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.6,
                max_tokens=1200
            )
            
            return {
                "optimized_assessment": response.choices[0].message.content,
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"Error optimizing assessment: {str(e)}")
            return {
                "error": f"Failed to optimize assessment: {str(e)}",
                "optimized_assessment": assessment_content,
                "status": "fallback"
            }
    
    def enhance_activities(
        self,
        activities_content: str,
        subject: str,
        grade: str,
        duration: int = 45,
        resources: str = "Basic classroom materials",
        class_size: int = 30
    ) -> Dict:
        """
        Enhance classroom activities for better engagement and cultural relevance.
        
        Args:
            activities_content: Current activities content
            subject: Subject area
            grade: Grade level
            duration: Available time in minutes
            resources: Available resources
            class_size: Number of students
            
        Returns:
            Dict containing enhanced activities
        """
        try:
            prompt = ACTIVITY_ENHANCEMENT_PROMPT.format(
                activities_content=activities_content,
                subject=subject,
                grade=grade,
                duration=duration,
                resources=resources,
                class_size=class_size
            )
            
            system_message = f"You are an educational activity specialist for {subject} in {grade} level. Focus on creating engaging, culturally relevant activities."
            
            response = self._make_api_call(
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=1200
            )
            
            return {
                "enhanced_activities": response.choices[0].message.content,
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"Error enhancing activities: {str(e)}")
            return {
                "error": f"Failed to enhance activities: {str(e)}",
                "enhanced_activities": activities_content,
                "status": "fallback"
            }
    
    def align_curriculum(
        self,
        lesson_content: str,
        subject: str,
        grade: str,
        country: str = "Nigeria"
    ) -> Dict:
        """
        Align lesson content with curriculum standards.
        
        Args:
            lesson_content: Lesson content to align
            subject: Subject area
            grade: Grade level
            country: Country for curriculum standards
            
        Returns:
            Dict containing curriculum alignment analysis
        """
        try:
            prompt = CURRICULUM_ALIGNMENT_PROMPT.format(
                lesson_content=lesson_content,
                subject=subject,
                grade=grade,
                country=country
            )
            
            system_message = f"You are a curriculum specialist for {subject} in {grade} level in {country}. Focus on accurate curriculum mapping and alignment."
            
            response = self._make_api_call(
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                max_tokens=1000
            )
            
            return {
                "curriculum_alignment": response.choices[0].message.content,
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"Error aligning curriculum: {str(e)}")
            return {
                "error": f"Failed to align curriculum: {str(e)}",
                "curriculum_alignment": "Curriculum alignment analysis unavailable",
                "status": "fallback"
            }
    
    def explain_ai_content(self, content: str, context: str) -> str:
        """
        Explain AI-generated content in teacher-friendly terms with enhanced context.
        
        Args:
            content: The AI-generated content to explain
            context: Context for the explanation
            
        Returns:
            Explanation text
        """
        try:
            prompt = EXPLANATION_PROMPT.format(
                content=content,
                context=context
            )
            
            system_message = "You are a supportive educational mentor explaining AI suggestions to African teachers. Use clear, practical language."
            
            response = self._make_api_call(
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                max_tokens=800
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            logger.error(f"Error explaining content: {str(e)}")
            return f"Unable to generate explanation: {str(e)}"
    
    def _make_api_call(self, messages: List[Dict], temperature: float = None, max_tokens: int = None) -> Any:
        """
        Make API call with retry logic and error handling.
        
        Args:
            messages: List of message dictionaries
            temperature: Temperature for response generation
            max_tokens: Maximum tokens for response
            
        Returns:
            API response
        """
        for attempt in range(self.retry_attempts):
            try:
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                    temperature=temperature or self.default_temperature,
                    max_tokens=max_tokens or self.default_max_tokens
                )
                return response
                
            except Exception as e:
                logger.warning(f"API call attempt {attempt + 1} failed: {str(e)}")
                if attempt == self.retry_attempts - 1:
                    raise e
                continue
    
    def _structure_lesson_plan(self, content: str, subject: str, grade: str, topic: str, objectives: Optional[List[str]] = None, curriculum_standards: Optional[List[str]] = None) -> Dict:
        """Structure the raw AI response into a lesson plan format with enhanced parsing."""
        # Extract objectives from content if not provided
        extracted_objectives = objectives or self._extract_objectives(content)
        
        return {
            "title": f"{subject}: {topic}",
            "subject": subject,
            "grade": grade,
            "topic": topic,
            "objectives": extracted_objectives,
            "curriculum_standards": curriculum_standards or [],
            "learning_objectives": self._extract_section(content, "LEARNING OBJECTIVES"),
            "local_context": self._extract_section(content, "LOCAL CONTEXT INTEGRATION"),
            "core_content": self._extract_section(content, "CORE CONTENT"),
            "activities": self._extract_section(content, "ENGAGING ACTIVITIES"),
            "assessment": self._extract_section(content, "ASSESSMENT & EVALUATION"),
            "projects": self._extract_section(content, "RELATED PROJECTS & EXTENSIONS"),
            "teacher_notes": self._extract_section(content, "TEACHER NOTES"),
            "content": content
        }
    
    def _extract_section(self, content: str, section_name: str) -> str:
        """Extract a specific section from the AI response with improved parsing."""
        lines = content.split('\n')
        section_content = []
        in_section = False
        
        for line in lines:
            # Check for section headers (both ## and # format)
            if section_name.upper() in line.upper() and ('#' in line or line.strip().isupper()):
                in_section = True
                continue
            if in_section:
                # Check if we've reached the next section
                if any(next_section in line.upper() for next_section in [
                    "LEARNING OBJECTIVES", "LOCAL CONTEXT", "CORE CONTENT", 
                    "ENGAGING ACTIVITIES", "ASSESSMENT", "RELATED PROJECTS", "TEACHER NOTES"
                ]):
                    break
                if line.strip():
                    section_content.append(line.strip())
        
        return '\n'.join(section_content)
    
    def _extract_objectives(self, content: str) -> List[str]:
        """Extract learning objectives from AI response with improved parsing."""
        lines = content.split('\n')
        objectives = []
        in_objectives = False
        
        for line in lines:
            if "LEARNING OBJECTIVES" in line.upper():
                in_objectives = True
                continue
            if in_objectives:
                if any(section in line.upper() for section in ["LOCAL CONTEXT", "CORE CONTENT", "ACTIVITIES"]):
                    break
                if line.strip() and not line.startswith('#'):
                    # Clean up the objective line
                    objective = line.strip().lstrip('- ').lstrip('* ').lstrip('1. ').lstrip('2. ').lstrip('3. ').lstrip('4. ').lstrip('5. ')
                    if objective and len(objective) > 10:  # Filter out very short lines
                        objectives.append(objective)
        
        return objectives[:5] if objectives else [f"Understand {topic}", f"Apply {topic} concepts", f"Analyze {topic} examples"]
    
    def _generate_fallback_lesson_plan(self, subject: str, grade: str, topic: str, objectives: Optional[List[str]] = None) -> Dict:
        """Generate a comprehensive fallback lesson plan when AI fails."""
        fallback_objectives = objectives or [f"Understand {topic}", f"Apply {topic} concepts", f"Analyze {topic} examples"]
        return {
            "title": f"{subject}: {topic}",
            "subject": subject,
            "grade": grade,
            "topic": topic,
            "objectives": fallback_objectives,
            "curriculum_standards": [],
            "learning_objectives": f"Students will understand and apply {topic} concepts in {subject}",
            "local_context": f"Adapt {topic} concepts to local environment and available resources",
            "core_content": f"Core concepts and principles of {topic} in {subject}",
            "activities": [
                "Introduction Activity (5-10 min): Engage students with real-world examples",
                "Main Learning Activity (20-25 min): Explore core concepts through guided practice",
                "Group Work (10-15 min): Collaborative learning and peer support",
                "Individual Practice (5-10 min): Independent application and reinforcement",
                "Assessment Activity (5-10 min): Check understanding and provide feedback"
            ],
            "assessment": f"Assessment questions and activities related to {topic}",
            "projects": f"Project ideas and extensions for {topic} learning",
            "teacher_notes": f"Pedagogical notes and implementation tips for {topic} lesson",
            "content": f"Comprehensive {subject} lesson plan on {topic} for {grade} level"
        }
    
 